// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modelo que armazena os dados dos tenants
model Tenant {
  id             String         @id
  name           String
  domain         String
  smtpHost       String?
  smtpPort       Int?
  smtpUser       String?
  smtpPass       String?
  smtpTls        Boolean?
  smsDevKey      String?
  pushInPayToken String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @default(now()) @updatedAt
  User           User[]
  Organization   Organization[]
  Resource       Resource[]
  Permission     Permission[]
  Role           Role[]
  Service        Service[]

  @@map("tenants")
}

enum EUserStatus {
  ACTIVE
  BLOCKED
  SUSPENDED
}

// Modelo que armazena os usuários
model User {
  id                    String           @id
  tenantId              String
  tenant                Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  status                EUserStatus      @default(ACTIVE)
  lockReason            String?
  firstName             String
  lastName              String?
  email                 String
  emailUpdate           String?
  emailVerifiedAt       DateTime?
  phoneNumber           String
  phoneNumberUpdate     String?
  phoneNumberVerifiedAt DateTime?
  password              String
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @default(now()) @updatedAt
  Member                Member[]
  Confirmation          Verification[]
  UserPermission        UserPermission[]

  @@map("users")
}

enum EVerificationContext {
  CONFIRM // Confirmar um valor (email, telefone, etc)
  RECOVERY // Recuperar conta
}

enum EVerificationMethod {
  EMAIL
  PHONE
}

model Verification {
  id        String               @id
  userId    String?
  user      User?                @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  code      String               @unique
  context   EVerificationContext
  method    EVerificationMethod
  createdAt DateTime             @default(now())
  updatedAt DateTime             @default(now()) @updatedAt

  @@map("verifications")
}

// Modelo que armazena as organizações
model Organization {
  id           String         @id
  tenantId     String
  tenant       Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name         String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now()) @updatedAt
  Member       Member[]
  Webhook      Webhook[]
  Subscription Subscription[]
  Charge       Charge[]
  Key          Key[]
  Role         Role[]

  @@map("organizations")
}

// Modelo que armazena as chaves de API das organizações
model Key {
  id             String          @id
  organizationId String
  organization   Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  value          String          @unique // Chave de API
  disabled       Boolean?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @default(now()) @updatedAt
  KeyPermission  KeyPermission[]

  @@map("keys")
}

enum EMemberStatus {
  ACTIVE // Membro ativo
  INVITED // Convite enviado
  DISABLED // Membro desativado
}

// Modelo que relaciona os usuário como participantes de organizações
model Member {
  id             String        @id
  userId         String?
  user           User?         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  status         EMemberStatus @default(INVITED)
  owner          Boolean?
  inviteEmail    String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @default(now()) @updatedAt
  MemberRole     MemberRole[]

  @@map("members")
}

// pivot
model MemberRole {
  memberId String
  member   Member @relation(fields: [memberId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  roleId   String
  role     Role   @relation(fields: [roleId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([memberId, roleId])
  @@map("memberRole")
}

// Modelo que armazena as roles de organizações
model Role {
  id             String           @id
  tenantId       String
  tenant         Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  organizationId String
  organization   Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name           String
  description    String?
  selfManaged    Boolean? // Determina se a role só pode ser alterada pelo sistema
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @default(now()) @updatedAt
  MemberRole     MemberRole[]
  RolePermission RolePermission[]

  @@map("roles")
}

// Modelo que armazena as permissões do sistema
model Permission {
  id             String           @unique
  tenantId       String
  tenant         Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name           String?
  description    String?
  value          String
  restrict       Boolean? // Se a permissão for restrita, então ela só pode ser atribuída pelos pelos proprietários do sistema e não estará disponível para uso nas organizações
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @default(now()) @updatedAt
  RolePermission RolePermission[]
  KeyPermission  KeyPermission[]
  UserPermission UserPermission[]

  @@id([tenantId, value])
  @@map("permissions")
}

// (pivot) Modelo que relaciona usuários diretamente às permissões (Para acesso administrativo)
model UserPermission {
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([userId, permissionId])
  @@map("userPermission")
}

// pivot
model RolePermission {
  roleId       String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([roleId, permissionId])
  @@map("rolePermission")
}

// pivot
model KeyPermission {
  keyId        String
  key          Key        @relation(fields: [keyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([keyId, permissionId])
  @@map("keyPermission")
}

model Webhook {
  id             String           @id
  organizationId String
  organization   Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name           String
  description    String
  url            String
  disabled       Boolean?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @default(now()) @updatedAt
  WebhookHistory WebhookHistory[]

  @@map("webhooks")
}

model WebhookHistory {
  id        String   @id
  webhookId String
  webhook   Webhook  @relation(fields: [webhookId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  request   Json?
  response  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@map("webhookHistory")
}

model Subscription {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  offerId        String
  offer          Offer        @relation(fields: [offerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  nextCharge     DateTime? // Data da próxima cobrança do valor da oferta
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt

  @@map("subscriptions")
}

enum EChargeStatus {
  PAID
  PENDING
  CANCELED
}

model Charge {
  id             String        @id
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  offerId        String
  offer          Offer         @relation(fields: [offerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  status         EChargeStatus @default(PENDING)
  amount         Int?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @default(now()) @updatedAt

  @@map("charges")
}

model Service {
  id        String   @id
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  Offer     Offer[]

  @@map("services")
}

enum EOfferRecurrence {
  MONTHLY // A cada 1 mês
  QUARTERLY // A cada 3 meses
  SEMMONLY // A cada 6 meses
  YEARLY // A cada 12 meses
}

enum EOfferStatus {
  ACTIVE // Funcional e disponível à qualquer um
  PRIVATE // Restrito à grupos específicos (Exige configuração manual)
  DISABLED // Desativado (Não disponível à ninguém)
}

model Offer {
  id           String            @id
  serviceId    String
  service      Service           @relation(fields: [serviceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  status       EOfferStatus      @default(DISABLED)
  name         String
  description  String?
  amount       Int?
  recurrence   EOfferRecurrence?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @default(now()) @updatedAt
  Benefit      Benefit[]
  Subscription Subscription[]
  Charge       Charge[]

  @@map("offers")
}

model Resource {
  id          String    @unique
  tenantId    String
  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name        String
  description String?
  key         String // Chave local do recurso do sistema
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt
  Benefit     Benefit[]

  @@id([tenantId, key])
  @@map("resources")
}

model Benefit {
  offerId    String
  offer      Offer    @relation(fields: [offerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  resourceId String
  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  value      Int?

  @@id([offerId, resourceId])
  @@map("benefits")
}
